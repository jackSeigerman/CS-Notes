# COMP 485 SENIOR SOFTWARE ENGINEERING

- Instructor: Sean Kugele
- Notes Written by: Jack Seigerman
- Year: Fall 2025



## Software Engineering

the application of a systematic, disiplined, quanitifiabe approach to the development operation and maintencance of software that is the application of engineering to software - IEEE

software engineering bridges the gap between the act of programming and the larger goals of an engineering a sofware product that is robust mainanable and scalable it involves integrating programming skills with principles from ther enginerring disciplines to solve complex software problems - code complete 

software enginerring is an engineering discipline that is concerned with a; aspectes of software porduction from initaial conception to operation and maintencance - softeare engineering 10 edition

the multiperson development of multiversion software -dave parnas and others

programming is immediate act of producing code, softeare engineering is the set of policies, practicesm and tools, that are necessary to make code useful over time and allowing collaboration across a team

google classifies the three bigest factors between SWE and Programming

- time
- scale
- complexity

the expected lifespan of software may vary by a factor of 100,000 minutes or decades

software must change or be replaced

softeare change happes for all kind of reasons
like security, money, legal reasons, external depencies

sustainabilty

your project is sustainable if the expexted life span of your software you are capable of reacting to whatever valuable change comes along for either tech or buissness reasons

what reduces sustainabilty?

- obfuscated and hard to understand code
- repetition
- interdepencies
- unesseary complexity

The essence of good design 

ETC easy to change


Hyrums law - the law of implicit dependencies

"given enough users of a system it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody."

relying on implicit or non contractual behaviors is typically a really bad idea

software lifespan

extremly difficult to estimate software lifespaen , typically multi versions needed.

## VCS

### centralized VCS

- simple
- single source of truth
- single point of failue
- harder to work offline

### Distributed VCS

- redundancy (saftey)
- faster (most operations are local)
- better offline operation
- redundancy (multiple sources of truth)
- complexity

### Trunk based development

building on a single branch

